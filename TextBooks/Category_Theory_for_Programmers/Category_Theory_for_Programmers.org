* Chapter 1: Category: The Essence of Compositions
** Notes
*** Category is a collection of objects and arrows
*** A category should have two basic properties
    1. Ability to compose associatevely
       h \circ (g \circ f) = (h \circ g) \circ f = h \circ g \circ f
    2. Existence of identity function
       f \circ id_A = f
** Challenges
*** Q1
    #+begin_src cpp
     #include <iostream>
     /*template<typename T>
     T identity(T x) {
       return x;
     }*/
     auto identity = [](auto x) {
         return x;
     };

     int main() {
         std::cout<< identity(1)<<std::endl;
         std::cout<< identity(2)<<std::endl;
         return 0;
     }
    #+end_src

    #+RESULTS:
    | 1 |
    | 2 |

*** Q2
    #+begin_src cpp
    #include<iostream>
    #include<assert.h>
    auto compose = [](auto f, auto g) {
      return [f,g](auto z) {
        return f(g(z));
      };
    };
    auto square = [](auto x) {
      return x*x;
    };
    auto cube = [](auto x) {
      return x*x*x;
    };
    int main() {
      auto square_of_cube = compose(square,cube);
      assert(square_of_cube(2) == 64);
      std::cout<<"square(cube(2)) = "<<square_of_cube(2)<<"\n";
      assert(square_of_cube(3) == 729);
      std::cout<<"square(cube(3)) = "<<square_of_cube(3)<<"\n";
      return 0;
    }
    #+end_src

    #+RESULTS:
    | square(cube(2)) | = |  64 |
    | square(cube(3)) | = | 729 |
*** Q3
    #+begin_src cpp
    #include<iostream>
    #include<assert.h>
    auto compose = [](auto f, auto g) {
      return [f,g](auto z) {
        return f(g(z));
      };
    };
    auto identity = [](auto x) {
         return x;
     };
    auto square = [](auto x) {
      return x*x;
    };
    int main() {
      auto square_of = compose(square,identity);
      assert(square_of(2) == 4);
      std::cout<<"square(id(2)) = "<<square_of(2)<<"\n";
      assert(square_of(3) == 9);
      std::cout<<"square(id(3)) = "<<square_of(3)<<"\n";
      return 0;
    }
    #+end_src

    #+RESULTS:
    | square(id(2)) | = | 4 |
    | square(id(3)) | = | 9 |
*** Q4
    The world wide web is a category with the web page as the objects
    and the links as the arrows.
    1. The www satisfies the identity principle since the link to a
       page takes us to that page.
    2. The associativity is satisfied such that if we can get from A
       -> B and from B -> C then we can reach A -> C
*** Q5
    If we consider the people as objects and the friendship as the
    arrows. This does not form a category.
    1. The identity principle is not satisfied as A is not a friend of A
    2. The associativity rule is not satisfied because if A is a
       friend of B and B is a friend of C does not imply that A is a
       friend of C
*** Q6
    A directed graph will be a category when there is an edge pointing
    back to each node from itself satisfying the identity principle
    and when for every node A -> B and  from B-> C there is an edge
    from A -> C
* Chapter 2: Types and Functions
** Notes
*** Halting problem -
    Given a program or algorithm is there a way to detect if the program will halt.
    This cannot be determined with a generalized algorithm
*** /Denotational Semantics/
    Every programming construct is given a mathematical interpretation
*** Pure & Dirty Functions
    A pure function is one that always produces the same result given
    the same input and does not have any side effects.
** Challenges
*** Q1
    #+begin_src cpp
    #include <iostream>
    #include <unordered_map>
    #include <functional>
    #include <chrono>
    #include <thread>

    template <typename T>
    std::function<T(T)>memoize(T(*f)(T)) {
      std::unordered_map<T,T> storage;
      return [f, storage](T x)mutable { // the mutable is required because capture by values cannot be  modified
        const auto it = storage.find(x);
	if(it == storage.end()) {
	  return storage.insert(std::make_pair(x, f(x))).first->second;
	} else {
	  return it->second;
	}
      };
    }

    int square (int x) {
      std::this_thread::sleep_for(std::chrono::seconds(10));
      return x*x;
    }

    auto square_mem = memoize(square);
    int main() {
      std::cout<<square_mem(2)<<"\n";
      std::cout<<square_mem(3)<<"\n";
      std::cout<<square_mem(2)<<"\n";
      return 0;
    }
    #+end_src

    #+RESULTS:
    | 4 |
    | 9 |
    | 4 |

*** Q2
    The rand function is supposed to return random numbers at each
    call memoizing this function will not be meaningful as it will
    Since the rand function in C++ is not called with an argument what
    will this be memoized against. rand() is not a pure function as it
    relies on the state of the CPU clock to generate the random number.

*** Q3
    With random number generators that take a seed the value returned
    by the random number sequence generated by the random number
    generator is the same. Here this will be usefull if we can store
    the entire sequence of random numbers generated.

*** Q4
    1. Factorial function is a pure function as it does not create any
       side effect and for any given number will always return the
       same output value.
    2. std::getchar() is based on the state of the STDIN hence not pure
    3. the cout statement writes to the STDOUT this is a side
       effect. Hence not pure
    4. using static in C/C++ means there is a state  stored and hence
       this is not a pure function
*** Q5
    Since bool has 2 values a total of 2^2 values are possible
    #+begin_src cpp
    #include <iostream>
    bool id(bool x) {
      return x;
    }
    bool alwaysTrue(bool x) {
      return true;
    }
    bool alwaysFalse(bool x) {
      return false;
    }
    bool NOT(bool x) {
      return !x;
    }

    int main() {
      bool x{false};
      std::cout<<id(x)<<std::endl;
      std::cout<<alwaysTrue(x)<<std::endl;
      std::cout<<alwaysFalse(x)<<std::endl;
      std::cout<<NOT(x)<<std::endl;
      return 0;
    }
    #+end_src

    #+RESULTS:
    | 0 |
    | 1 |
    | 0 |
    | 1 |
*** Q6
   Bool -> Bool 
   contains id, alwaysTrue, alwaysFalse, and NOT
   Bool -> Unit contains unit
   Unit ->Unit  is id
   Unit -> Bool is true and false
   Void -> Unit is absurd
   Void -> Bool is absurd
